import * as io from "io-ts";
import { MAX_BUFFER_LENGTH_SECONDS as BUFFER_DURATION } from "shared/audio";
import { FileReferenceDeletedError, isOutOfMemoryError } from "shared/errors";
import KeyValueDatabase from "shared/idb/KeyValueDatabase";
import TagDatabase from "shared/idb/TagDatabase";
import {
    ALBUM_ART_PREFERENCE_ALL,
    ALBUM_ART_PREFERENCE_SMALLEST,
    AlbumArtPreference,
    ChannelCount,
    CodecName,
    FileReference,
    fileReferenceToTrackUid,
    MetadataManagerBackendActions,
    MetadataResult,
    TagData,
    TagDataWithCriticalDemuxData,
    TrackInfo,
    TrackMetadata,
} from "shared/metadata";
import { DatabaseClosedResult } from "shared/platform/DatabaseClosedEmitterTrait";
import { debugFor } from "shared/src/debug";
import { LogFunction, RemoveFirst } from "shared/types/helpers";
import { _, ajaxGet, delay, hexString, queryString, toCorsUrl, trackInfoFromFileName } from "shared/util";
import { CancellationToken, CancellationTokenOpts } from "shared/utils/CancellationToken";
import WebAssemblyWrapper from "shared/wasm/WebAssemblyWrapper";
import AbstractBackend from "shared/worker/AbstractBackend";
import AudioProcessingPipeline from "shared/worker/AudioProcessingPipeline";
import getCodec from "shared/worker/codec";
import Fingerprinter from "shared/worker/Fingerprinter";
import JobProcessor from "shared/worker/JobProcessor";
import LoudnessAnalyzer from "shared/worker/LoudnessAnalyzer";
import getCodecName from "shared/worker/sniffer";

import parseAcoustId, { AcoustIdResponse, CoverArtResponse, ParsedAcoustIdResult } from "./acoustId";
import parseMp3Metadata from "./mp3_metadata";
import SearchBackend from "./SearchBackend";
const dbg = debugFor("MetadataBackend");

const imageDescriptionWeights = {
    Front: 0,
    Back: 1,
    Tray: 2,
    Booklet: 3,
    Medium: 4,
};

interface InitialTrackData {
    trackUid: ArrayBuffer;
    codecName: null | CodecName;
    duration: number;
    autogenerated: boolean;
}

export const JOB_STATE_INITIAL = `initial`;
export const JOB_STATE_DATA_FETCHED = `dataFetched`;

const IMAGE_TYPE_KEY = `imageType`;
const IMAGE_TYPE_COVERARTARCHIVE = `coverartarchive`;
const IMAGE_TYPE_BLOB = `blob`;

const CoverArtArchiveImage = io.type({
    [IMAGE_TYPE_KEY]: io.literal(IMAGE_TYPE_COVERARTARCHIVE),
    types: io.array(io.keyof(imageDescriptionWeights)),
    front: io.boolean,
    back: io.boolean,
    edit: io.number,
    image: io.string,
    comment: io.string,
    approved: io.boolean,
    id: io.string,
    thumbnails: io.record(io.string, io.string),
});
type CoverArtArchiveImage = io.TypeOf<typeof CoverArtArchiveImage> & {};
const BlobImage = io.type({
    [IMAGE_TYPE_KEY]: io.literal(IMAGE_TYPE_BLOB),
    description: io.keyof(imageDescriptionWeights),
});
type BlobImage = io.TypeOf<typeof BlobImage> & { image: Blob };

type ImageType = CoverArtArchiveImage | BlobImage;

export const METADATA_UPDATE_EVENT = `metadataUpdate`;

const NO_JOBS_FOUND_TOKEN = {};
const JOBS_FOUND_TOKEN = {};

const MAX_BLOB_URL_SIZE = 1024 * 1024 * 2;

const imageTypeKeyWeights = {
    [IMAGE_TYPE_BLOB]: 0,
    [IMAGE_TYPE_COVERARTARCHIVE]: 1,
};

const codecNotSupportedError = function () {
    const e = new Error(`codec not supported`);
    e.name = `CodecNotSupportedError`;
    return e;
};

const runknown = /^[\s<{[(]*unknown[}\])>\s]*$/i;
const isUnknown = function (value?: any) {
    if (!value) {
        return true;
    }
    return runknown.test(`${value}`);
};

function getDescriptionWeight(image: ImageType) {
    if ("description" in image) {
        const weight = imageDescriptionWeights[image.description];
        if (typeof weight !== `number`) {
            return -1;
        }
        return weight;
    } else if (Array.isArray(image.types)) {
        const weight = imageDescriptionWeights[image.types[0]!];
        if (typeof weight !== `number`) {
            return imageDescriptionWeights.Booklet + 1;
        }
        return weight;
    } else {
        return -1;
    }
}

function buildTrackInfo(metadata: InitialTrackData & TagData, demuxData: Partial<TrackMetadata>): TrackInfo {
    const {
        title = undefined,
        album = undefined,
        artist = undefined,
        albumArtist = undefined,
        year = undefined,
        albumIndex = 0,
        trackCount = 1,
        genres = [],
    } = metadata;
    return Object.assign(
        {},
        metadata,
        {
            lastPlayed: new Date(0),
            rating: -1,
            playthroughCounter: 0,
            skipCounter: 0,
            hasBeenFingerprinted: false,
            hasInitialLoudnessInfo: false,
            title,
            album,
            artist,
            albumArtist,
            year,
            albumIndex,
            trackCount,
            genres,
            demuxData,
        },
        {
            sampleRate: demuxData.sampleRate!,
            channels: demuxData.channels!,
            duration: demuxData.duration!,
        }
    );
}

type JobProcessorOfMethod<MethodName extends keyof MetadataManagerBackend> = JobProcessor<
    RemoveFirst<Parameters<MetadataManagerBackend[MethodName]>>,
    ReturnType<MetadataManagerBackend[MethodName]>
>;

interface BlobUrl {
    url: string;
    size: number;
}

export default class MetadataManagerBackend extends AbstractBackend<
    MetadataManagerBackendActions<MetadataManagerBackend>,
    "metadata"
> {
    _fingerprinter: JobProcessorOfMethod<"_fingerprintJob">;
    _loudnessAnalyzerStateSerializer: JobProcessorOfMethod<"_loudnessAnalysisJob">;
    _kvdb: KeyValueDatabase | null;
    _tagdb: TagDatabase;
    _searchBackend: SearchBackend;
    _wasm: WebAssemblyWrapper;
    _blobUrls: BlobUrl[];
    _blobUrlSize: number;
    _trackInfoEntriesCount: number;
    _acoustIdDataFetcher: JobProcessorOfMethod<"_fetchAcoustIdDataJob">;
    _metadataParser: JobProcessorOfMethod<"_parseMetadataJob">;
    _coverArtDownloader: JobProcessor<[string], Promise<Blob | null>>;
    _logFn: LogFunction;

    constructor(wasm: WebAssemblyWrapper, database: TagDatabase, searchBackend: SearchBackend, logFn: LogFunction) {
        super("metadata", {
            setRating({ trackUid, rating }) {
                if (!this.canUseDatabase()) return;
                void this._tagdb.updateRating(trackUid, rating);
            },

            setSkipCounter({ trackUid, counter, lastPlayed }) {
                if (!this.canUseDatabase()) return;
                void this._tagdb.updateSkipCounter(trackUid, counter, lastPlayed);
            },

            setPlaythroughCounter({ trackUid, counter, lastPlayed }) {
                if (!this.canUseDatabase()) return;
                void this._tagdb.updatePlaythroughCounter(trackUid, counter, lastPlayed);
            },

            async getAlbumArt({ trackUid, artist, album, preference, requestReason }) {
                if (!this.canUseDatabase()) return;
                const albumArt = await this._getAlbumArt(trackUid, artist, album, preference);
                this.postMessageToMetadataFrontend({ type: "albumArt", albumArt, trackUid, preference, requestReason });
            },

            async parseMetadata({ fileReference }) {
                if (!this.canUseDatabase()) return;
                const trackUid = await fileReferenceToTrackUid(fileReference);
                const result = await this._parseMetadata(trackUid, fileReference);
                if (!result) {
                    return;
                }
                this.postMessageToMetadataFrontend({
                    type: "trackMetadata",
                    trackInfo: result.trackInfo,
                    trackUid: result.trackUid,
                    error: result.error,
                });

                if (result.trackInfo) {
                    if (!result.trackInfo.hasBeenFingerprinted) {
                        this._fingerprinter.postJob(trackUid, fileReference);
                    }

                    if (!result.trackInfo.hasInitialLoudnessInfo) {
                        this._loudnessAnalyzerStateSerializer.postJob(trackUid, fileReference);
                    }
                }
            },

            async getTrackInfoBatch({ batch }) {
                const label = "getTrackInfoBatch";
                if (!this.canUseDatabase()) return;
                const missing: ArrayBuffer[] = [];
                const trackInfos = await this._tagdb.trackUidsToTrackInfos(batch, missing);
                for (let i = 0; i < trackInfos.length; ++i) {
                    const trackInfo = trackInfos[i];
                    const { trackUid } = trackInfo;
                    if (!trackInfo.hasBeenFingerprinted) {
                        this._fingerprinter.postJob(trackUid, trackUid);
                    }

                    if (!trackInfo.hasInitialLoudnessInfo) {
                        this._loudnessAnalyzerStateSerializer.postJob(trackUid, trackUid);
                    }

                    if (trackInfo.duration === 0) {
                        missing.push(trackInfo.trackUid);
                    }
                }

                dbg(label, "missing", missing.length);

                for (let i = 0; i < missing.length; ++i) {
                    this.actions.parseMetadata.call(this, { fileReference: missing[i]! });
                }

                this.postMessageToMetadataFrontend({ type: "trackInfoBatch", trackInfos });
            },

            async mapTrackUidsToFiles({ trackUids }) {
                if (!this.canUseDatabase()) return;
                const missing: ArrayBuffer[] = [];
                const files = await this._tagdb.trackUidsToFiles(trackUids, missing);
                this.postMessageToMetadataFrontend({ type: "uidsMappedToFiles", files });

                for (let i = 0; i < missing.length; ++i) {
                    const trackUid = missing[i]!;
                    this.postMessageToMetadataFrontend({
                        type: "fileReferenceUnavailable",
                        trackUid,
                    });
                }
            },

            async parseTmpFile({ tmpFileId }) {
                if (!this.canUseDatabase()) return;
                await this._checkKvdb();
                const tmpFile = await this._kvdb!.consumeTmpFileById(tmpFileId);
                if (!tmpFile) {
                    return;
                }

                const { file } = tmpFile;
                const trackUid = await fileReferenceToTrackUid(file);
                const trackInfo = await this.getTrackInfoByTrackUid(trackUid);
                if (!trackInfo) {
                    const result = await this._parseMetadata(trackUid, file);
                    if (result && result.trackInfo) {
                        if (!result.trackInfo.hasBeenFingerprinted) {
                            this._fingerprinter.postJob(trackUid, trackUid);
                        }

                        if (!result.trackInfo.hasInitialLoudnessInfo) {
                            this._loudnessAnalyzerStateSerializer.postJob(trackUid, trackUid);
                        }
                        this.postMessageToMetadataFrontend({
                            type: "newTrackFromTmpFile",
                            trackInfo: result.trackInfo,
                        });
                    }
                } else {
                    try {
                        await this._tagdb.ensureFileStored(trackUid, file);
                    } catch (e) {
                        if (!this._checkStorageError(e)) {
                            throw e;
                        }
                    }
                }
            },
        });
        this._logFn = logFn;
        this._searchBackend = searchBackend;
        this._wasm = wasm;
        this._blobUrls = [];
        this._blobUrlSize = 0;
        this._trackInfoEntriesCount = 0;
        this._kvdb = null;
        this._tagdb = database;

        this._loudnessAnalyzerStateSerializer = new JobProcessor({ jobCallback: this._loudnessAnalysisJob });
        this._acoustIdDataFetcher = new JobProcessor({
            delay: 1000,
            jobCallback: this._fetchAcoustIdDataJob,
        });
        this._fingerprinter = new JobProcessor({ jobCallback: this._fingerprintJob });
        this._metadataParser = new JobProcessor({ jobCallback: this._parseMetadataJob, parallelJobs: 8 });
        this._coverArtDownloader = new JobProcessor({
            async jobCallback({ cancellationToken }, url) {
                while (!cancellationToken.isCancelled()) {
                    try {
                        const result = await ajaxGet<Blob>(toCorsUrl(url), cancellationToken, { responseType: `blob` });
                        return result;
                    } catch (e) {
                        await delay(10000);
                    }
                }
                return null;
            },
            parallelJobs: 3,
        });

        this._acoustIdDataFetcher.on("jobComplete", async job => {
            const result = await job.promise;
            if (result !== NO_JOBS_FOUND_TOKEN) {
                this._acoustIdDataFetcher.postJob();
            }
        });
        this._acoustIdDataFetcher.postJob();
        this._metadataParser.on("allJobsComplete", () => {
            this.postMessageToMetadataFrontend({ type: "allFilesPersisted" });
        });
        void this._updateMediaLibrarySize();
    }

    _trackInfoEntriesCountUpdated() {
        this.postMessageToMetadataFrontend({
            type: "mediaLibrarySizeCount",
            count: this._trackInfoEntriesCount,
        });
    }

    async _updateMediaLibrarySize() {
        const count = await this._tagdb.getTrackInfoCount();
        this._trackInfoEntriesCount = count;
        this._trackInfoEntriesCountUpdated();
    }

    async _parseMetadata(trackUid: ArrayBuffer, fileReference: FileReference) {
        try {
            const trackInfo = await this._metadataParser.postJob(trackUid, fileReference).promise;
            if (!trackInfo) {
                return null;
            }
            return { trackInfo, trackUid };
        } catch (e) {
            if (e instanceof FileReferenceDeletedError) {
                this.postMessageToMetadataFrontend({
                    type: "fileReferenceUnavailable",
                    trackUid,
                });
                return null;
            } else {
                return { trackUid, error: { message: e.message } };
            }
        }
    }

    async getLoudnessAnalyzerStateForTrack(trackUid: ArrayBuffer) {
        return this._tagdb.getLoudnessAnalyzerStateForTrack(trackUid);
    }

    _loudnessAnalysisJob = async (
        { cancellationToken }: CancellationTokenOpts,
        trackUid: ArrayBuffer,
        fileReference: FileReference
    ) => {
        let decoder, loudnessAnalyzer;
        const { _wasm: wasm } = this;
        try {
            const trackInfo = await this.getTrackInfoByTrackUid(trackUid);

            if (!trackInfo || trackInfo.hasInitialLoudnessInfo) {
                return;
            }

            let fileView;
            try {
                fileView = await this._tagdb.fileReferenceToFileView(fileReference);
            } catch (e) {
                if (e instanceof FileReferenceDeletedError) {
                    this.postMessageToMetadataFrontend({
                        type: "fileReferenceUnavailable",
                        trackUid,
                    });
                    return;
                } else {
                    throw e;
                }
            }

            const DecoderContext = getCodec(trackInfo.codecName!);

            if (!DecoderContext) {
                throw new Error("unknown codec " + trackInfo.codecName);
            }

            const { sampleRate, duration, channels, demuxData } = trackInfo;
            const sourceSampleRate = sampleRate;
            const sourceChannelCount = channels as ChannelCount;
            const { dataStart, dataEnd } = demuxData;

            if (duration >= 15) {
                decoder = new DecoderContext(wasm, {
                    targetBufferLengthAudioFrames: BUFFER_DURATION * sampleRate,
                });
                decoder.start(demuxData as TrackMetadata);

                loudnessAnalyzer = new LoudnessAnalyzer(wasm);
                loudnessAnalyzer.initialize(sourceChannelCount, sourceSampleRate);

                const audioPipeline = new AudioProcessingPipeline(wasm, {
                    sourceSampleRate,
                    sourceChannelCount,
                    destinationSampleRate: sourceSampleRate,
                    destinationChannelCount: sourceChannelCount,
                    decoder,
                    bufferTime: BUFFER_DURATION,
                    duration,
                    bufferAudioFrameCount: sourceSampleRate * BUFFER_DURATION,
                    loudnessAnalyzer,
                });

                const fileStartPosition = dataStart!;
                let filePosition = fileStartPosition;
                const fileEndPosition = dataEnd!;

                while (filePosition < fileEndPosition && !loudnessAnalyzer.isHistoryStateFilled()) {
                    const bytesRead = await audioPipeline.decodeFromFileViewAtOffset(
                        fileView,
                        filePosition,
                        demuxData as TrackMetadata,
                        cancellationToken,
                        0
                    );
                    audioPipeline.consumeFilledBuffer();
                    filePosition += bytesRead;
                }

                const serializedState = loudnessAnalyzer.serialize();
                await this._tagdb.setLoudnessAnalyzerStateForTrack(trackUid, serializedState);
                await this._tagdb.updateHasInitialLoudnessInfo(trackUid, true);
            }
        } finally {
            if (decoder) decoder.destroy();
            if (loudnessAnalyzer) loudnessAnalyzer.destroy();
        }
    };

    _fingerprintJob = async (
        { cancellationToken }: CancellationTokenOpts,
        trackUid: ArrayBuffer,
        fileReference: FileReference
    ) => {
        let decoder, fingerprinter, audioPipeline;
        const { _wasm: wasm } = this;
        try {
            const trackInfo = await this.getTrackInfoByTrackUid(trackUid);

            if (!trackInfo || trackInfo.hasBeenFingerprinted) {
                return;
            }

            let fileView;
            try {
                fileView = await this._tagdb.fileReferenceToFileView(fileReference);
            } catch (e) {
                if (e instanceof FileReferenceDeletedError) {
                    this.postMessageToMetadataFrontend({
                        type: "fileReferenceUnavailable",
                        trackUid,
                    });
                    return;
                } else {
                    throw e;
                }
            }
            const DecoderContext = getCodec(trackInfo.codecName!);

            if (!DecoderContext) {
                throw new Error("unknown codec " + trackInfo.codecName);
            }

            const { sampleRate, duration, channels, demuxData } = trackInfo;
            const sourceSampleRate = sampleRate;
            const sourceChannelCount = channels as ChannelCount;
            const { dataStart, dataEnd } = demuxData;
            let fingerprint = null;

            if (duration >= 15) {
                decoder = new DecoderContext(wasm, {
                    targetBufferLengthAudioFrames: BUFFER_DURATION * sampleRate,
                });
                decoder.start(demuxData as TrackMetadata);

                fingerprinter = new Fingerprinter(wasm);
                const { destinationChannelCount, destinationSampleRate } = fingerprinter;
                audioPipeline = new AudioProcessingPipeline(wasm, {
                    sourceSampleRate,
                    sourceChannelCount,
                    destinationSampleRate,
                    destinationChannelCount,
                    decoder,

                    fingerprinter,
                    bufferTime: BUFFER_DURATION,
                    duration,
                    bufferAudioFrameCount: Math.round(destinationSampleRate * BUFFER_DURATION),
                });

                const fileStartPosition = dataStart;
                let filePosition: number = fileStartPosition!;
                const fileEndPosition = dataEnd;

                while (filePosition! < fileEndPosition! && fingerprinter.needFrames()) {
                    const bytesRead = await audioPipeline.decodeFromFileViewAtOffset(
                        fileView,
                        filePosition!,
                        demuxData as TrackMetadata,
                        cancellationToken,
                        0
                    );
                    audioPipeline.consumeFilledBuffer();
                    filePosition += bytesRead!;
                }
                fingerprint = fingerprinter.calculateFingerprint();
            }

            if (fingerprint) {
                await this._tagdb.updateHasBeenFingerprinted(trackUid, true);
                await this._tagdb.addAcoustIdFetchJob(trackUid, fingerprint, duration, JOB_STATE_INITIAL);
                this._acoustIdDataFetcher.postJob();
            }
        } finally {
            if (decoder) decoder.destroy();
            if (fingerprinter) fingerprinter.destroy();
            if (audioPipeline) audioPipeline.destroy();
        }
    };

    _fetchAcoustIdDataJob = async ({ cancellationToken }: CancellationTokenOpts) => {
        const job = await this._tagdb.getAcoustIdFetchJob();
        if (!job) {
            return NO_JOBS_FOUND_TOKEN;
        }

        const { trackUid, fingerprint, duration, jobId } = job;
        let { acoustIdResult, state } = job;
        let trackInfo;
        let trackInfoUpdated = false;
        const waitLongTime = !!job.lastError;

        if (state === JOB_STATE_INITIAL) {
            try {
                const result = await this._fetchAcoustId(cancellationToken, trackUid, fingerprint, duration);
                ({ acoustIdResult, trackInfo, trackInfoUpdated } = result);
                state = JOB_STATE_DATA_FETCHED;
                await this._tagdb.updateAcoustIdFetchJobState(jobId, { acoustIdResult, state });

                if (trackInfoUpdated) {
                    void this._searchBackend.updateTrackToSearchIndex(trackInfo);
                }
            } catch (e) {
                await this._tagdb.setAcoustIdFetchJobError(jobId, e);
                if (waitLongTime) {
                    await delay(10000);
                }
                return JOBS_FOUND_TOKEN;
            }
        }

        if (state === JOB_STATE_DATA_FETCHED) {
            if (acoustIdResult) {
                if (!trackInfo) {
                    trackInfo = await this.getTrackInfoByTrackUid(trackUid);
                }

                try {
                    const fetchedCoverArt = await this._fetchCoverArtInfo(cancellationToken, acoustIdResult, trackInfo);
                    if (!trackInfoUpdated) {
                        trackInfoUpdated = fetchedCoverArt;
                    }
                } catch (e) {
                    await this._tagdb.setAcoustIdFetchJobError(jobId, e);
                    if (waitLongTime) {
                        await delay(10000);
                    }
                    return JOBS_FOUND_TOKEN;
                }
            }
            await this._tagdb.completeAcoustIdFetchJob(jobId);
        }

        if (trackInfo) {
            this.postMessageToMetadataFrontend({ type: "acoustId", trackInfo, trackInfoUpdated });
        }
        if (waitLongTime) {
            await delay(10000);
        }
        return JOBS_FOUND_TOKEN;
    };

    getTrackInfoByTrackUid(trackUid: ArrayBuffer): Promise<TrackInfo> {
        return this._tagdb.getTrackInfoByTrackUid(trackUid);
    }

    _parseMetadataJob = async (_job: any, trackUid: ArrayBuffer, fileReference: FileReference) => {
        const label = "parseMetadataJob";
        dbg(label, "started for ", hexString(trackUid));
        try {
            await this._tagdb.ensureFileStored(trackUid, fileReference);
        } catch (e) {
            if (this._checkStorageError(e)) {
                return null;
            }
            throw e;
        }
        let trackInfo = await this.getTrackInfoByTrackUid(trackUid);

        if (trackInfo && trackInfo.duration > 0) {
            void this._searchBackend.addTrackToSearchIndexIfNotPresent(trackInfo);
            return trackInfo;
        }

        const data: TagDataWithCriticalDemuxData & InitialTrackData = {
            trackUid,
            codecName: null,
            duration: 0,
            autogenerated: false,
            demuxData: {
                sampleRate: 44100,
                channels: 2,
                duration: 0,
            },
        };

        const fileView = await this._tagdb.fileReferenceToFileView(fileReference);
        const codecName = await getCodecName(fileView);
        if (!codecName) {
            throw codecNotSupportedError();
        }

        switch (codecName) {
            case `wav`:
            case `webm`:
            case `aac`:
            case `ogg`:
                throw codecNotSupportedError();
            case `mp3`:
                await parseMp3Metadata(data, fileView);
                break;
            default:
                break;
        }
        data.codecName = codecName;
        data.duration = data.demuxData.duration;
        data.trackUid = trackUid;

        if (!data.artist || !data.title) {
            const { artist, title } = trackInfoFromFileName(fileView.file.name);
            data.artist = artist;
            data.title = title;
            data.autogenerated = true;
        }

        if (data.pictures) {
            const { pictures } = data;
            delete data.pictures;
            await this._tagdb.addAlbumArtData(trackUid, {
                trackUid,
                images: pictures.map(i => Object.assign({ [IMAGE_TYPE_KEY]: IMAGE_TYPE_BLOB }, i)),
                album: data.album || null,
                artist: data.artist,
            });
        }

        trackInfo = buildTrackInfo(data, data.demuxData);
        void this._searchBackend.updateTrackToSearchIndex(trackInfo);
        await this._tagdb.replaceTrackInfo(trackUid, trackInfo);
        this._trackInfoEntriesCount++;
        this._trackInfoEntriesCountUpdated();
        return trackInfo;
    };

    async _fetchAcoustId(
        cancellationToken: CancellationToken<any>,
        trackUid: ArrayBuffer,
        fingerprint: string,
        duration: number
    ) {
        const data = queryString({
            client: `djbbrJFK`,
            format: `json`,
            duration: `${duration | 0}`,
            meta: `recordings+releasegroups+compress`,
            fingerprint,
        });
        const url = `https://api.acoustId.org/v2/lookup?${data}`;

        let result: ParsedAcoustIdResult | undefined;
        const fullResponse = await ajaxGet<AcoustIdResponse>(toCorsUrl(url), cancellationToken);
        if (fullResponse.results && fullResponse.results.length > 0) {
            result = parseAcoustId(fullResponse, duration | 0);
        }
        const trackInfo = await this.getTrackInfoByTrackUid(trackUid);
        const wasAutogenerated = trackInfo.autogenerated;

        let trackInfoUpdated = false;
        if (result) {
            trackInfo.autogenerated = false;
            const {
                album: albumResult,
                title: titleResult,
                artist: artistResult,
                albumArtist: albumArtistResult,
            } = result;
            const { name: album } = albumResult || {};
            const { name: title } = titleResult || {};
            const { name: artist } = artistResult || {};
            const { name: albumArtist } = albumArtistResult || {};

            if ((isUnknown(trackInfo.title) || wasAutogenerated) && title) {
                trackInfo.title = title;
                trackInfoUpdated = true;
            }

            if ((isUnknown(trackInfo.album) || wasAutogenerated) && album) {
                trackInfo.album = album;
                trackInfoUpdated = true;
            }

            if ((isUnknown(trackInfo.albumArtist) || wasAutogenerated) && albumArtist) {
                trackInfo.albumArtist = albumArtist;
                trackInfoUpdated = true;
            }

            if ((isUnknown(trackInfo.artist) || wasAutogenerated) && artist) {
                trackInfo.artist = artist;
                trackInfoUpdated = true;
            }
        }

        await this._tagdb.replaceTrackInfo(trackUid, trackInfo);
        return {
            acoustIdResult: result || null,
            trackInfo,
            trackInfoUpdated,
        };
    }

    async _fetchCoverArtInfo(
        cancellationToken: CancellationToken<any>,
        acoustIdResult: Exclude<ParsedAcoustIdResult, null>,
        trackInfo: TrackInfo
    ) {
        const { trackUid } = trackInfo;
        const { album, title } = acoustIdResult;
        let mbid, type;

        if (album && album.mbid) {
            ({ mbid, type } = album);
        } else if (title && title.mbid) {
            ({ mbid, type } = title);
        } else {
            return false;
        }

        const { artist: taggedArtist, album: taggedAlbum } = trackInfo;
        try {
            const response = await ajaxGet<CoverArtResponse>(
                toCorsUrl(`https://coverartarchive.org/${type}/${mbid}`),
                cancellationToken
            );
            if (response && response.images && response.images.length > 0) {
                await this._tagdb.addAlbumArtData(trackUid, {
                    trackUid,
                    images: response.images.map(i =>
                        Object.assign({ [IMAGE_TYPE_KEY]: IMAGE_TYPE_COVERARTARCHIVE }, i)
                    ),
                    artist: taggedArtist,
                    album: taggedAlbum,
                });
                return true;
            }
        } catch (e) {
            if (e.status !== 404) {
                throw e;
            }
        }
        return false;
    }

    async _maybeDownloadCoverArt(url: string) {
        if (this._coverArtDownloader.jobsActive >= this._coverArtDownloader.parallelJobs) {
            await this._coverArtDownloader.cancelOldestJob();
        }
        try {
            const result = await this._coverArtDownloader.postJob(url).promise;
            return result;
        } catch (e) {
            return null;
        }
    }

    canUseDatabase() {
        if (this._tagdb.isClosed()) {
            const msg: DatabaseClosedResult = { type: "databaseClosed" };
            this.postMessageToFrontend([msg]);
            return false;
        }
        return true;
    }

    async _getAlbumArt(
        trackUid: ArrayBuffer,
        artist: string,
        album: string,
        preference: AlbumArtPreference = ALBUM_ART_PREFERENCE_SMALLEST
    ) {
        let result: null | Blob | (Blob | string)[] | string = null;

        const albumArtData = await this._tagdb.getAlbumArtData(trackUid, artist, album);
        if (!albumArtData) {
            result = preference === ALBUM_ART_PREFERENCE_ALL ? [] : null;
        } else {
            const images: ImageType[] = albumArtData.images || [];

            if (preference !== ALBUM_ART_PREFERENCE_ALL) {
                if (images.length > 0) {
                    images.sort((a: ImageType, b: ImageType) => {
                        const cmp = getDescriptionWeight(a) - getDescriptionWeight(b);
                        if (cmp !== 0) {
                            return cmp;
                        }
                        const aTypeWeight = imageTypeKeyWeights[a[IMAGE_TYPE_KEY]];
                        const bTypeWeight = imageTypeKeyWeights[b[IMAGE_TYPE_KEY]];
                        return aTypeWeight - bTypeWeight;
                    });

                    const image = images[0]!;

                    if (image.imageType === "blob") {
                        result = image.image;
                    } else if (image.imageType === "coverartarchive" && preference === ALBUM_ART_PREFERENCE_SMALLEST) {
                        result = image.thumbnails.small!;
                    } else {
                        result = image.image;
                    }

                    let blobResult: Blob | null = null;
                    if (typeof result === `string`) {
                        blobResult = await this._maybeDownloadCoverArt(result);
                    }

                    if (blobResult && image.imageType === "coverartarchive") {
                        result = blobResult;
                        await this._tagdb.addAlbumArtData(trackUid, {
                            trackUid,
                            images: [
                                {
                                    [IMAGE_TYPE_KEY]: IMAGE_TYPE_BLOB,
                                    image: blobResult,
                                    description: `${Array.isArray(image.types) ? image.types.join(`, `) : `none`}`,
                                },
                            ],
                            album,
                            artist,
                        });
                    }
                }
            } else {
                result = images.map(i => i.image);
            }
        }

        if (!result) {
            return result;
        } else if (Array.isArray(result)) {
            return result.map(this._mapToUrl, this);
        } else {
            return this._mapToUrl(result);
        }
    }

    _checkBlobList() {
        if (this._blobUrlSize > MAX_BLOB_URL_SIZE) {
            const target = (MAX_BLOB_URL_SIZE / 2) | 0;
            let blobUrlSize = this._blobUrlSize;
            while (blobUrlSize > target) {
                const { url, size } = this._blobUrls.shift()!;
                blobUrlSize -= size;
                try {
                    URL.revokeObjectURL(url);
                } catch (e) {
                    // NOOP
                }
            }
            this._blobUrlSize = blobUrlSize;
        }
    }

    _mapToUrl(value: Blob | string) {
        if (typeof value === `string`) {
            return value.replace(/^https?:\/\//i, `https://`);
        } else if (value instanceof Blob) {
            const url = URL.createObjectURL(value);
            const { size } = value;
            this._blobUrls.push({ url, size });
            this._blobUrlSize += size;
            this._checkBlobList();
            return url;
        } else {
            throw new Error(`unknown value ${value} ${typeof value}`);
        }
    }

    async _checkKvdb() {
        if (!this._kvdb) {
            this._kvdb = new KeyValueDatabase(this._logFn);
            await this._kvdb.getDb();
        }
    }

    _checkStorageError(e: Error) {
        if (isOutOfMemoryError(e)) {
            this.postMessageToMetadataFrontend({ type: "quotaExceeded" });
            return true;
        } else {
            return false;
        }
    }

    postMessageToMetadataFrontend<T extends MetadataResult>(result: T) {
        this.postMessageToFrontend([result]);
    }
}
